[1mdiff --git a/design/channels/serdes.sv b/design/channels/serdes.sv[m
[1mindex 8e602e5..9345f62 100644[m
[1m--- a/design/channels/serdes.sv[m
[1m+++ b/design/channels/serdes.sv[m
[36m@@ -1,3 +1,5 @@[m
[32m+[m[32m//`timescale 1ns / 10ps //siona added[m
[32m+[m
 module serializer#([m
     parameter HUB_FIFO_WIDTH = 32,[m
     parameter HUB_FIFO_PHYSICAL_WIDTH = 8 //this should exclude valid and ready or out of band signals[m
[1mdiff --git a/design/stage_controller/control_node_single_FPGA.v b/design/stage_controller/control_node_single_FPGA.v[m
[1mindex 5861e06..d93ca45 100644[m
[1m--- a/design/stage_controller/control_node_single_FPGA.v[m
[1m+++ b/design/stage_controller/control_node_single_FPGA.v[m
[36m@@ -1,7 +1,7 @@[m
 module unified_controller #([m
     parameter GRID_WIDTH_X = 4,[m
     parameter GRID_WIDTH_Z = 1,[m
[31m-    parameter GRID_WIDTH_U = 3,[m
[32m+[m[32m    parameter GRID_WIDTH_U = 5,[m
     parameter ITERATION_COUNTER_WIDTH = 8,  // counts to 255 iterations[m
     parameter MAXIMUM_DELAY = 2[m
 ) ([m
[36m@@ -63,6 +63,7 @@[m [moutput reg [7 : 0] output_data;[m
 output reg output_valid;[m
 input output_ready;[m
 [m
[32m+[m
 reg result_valid;[m
 reg [ITERATION_COUNTER_WIDTH-1:0] iteration_counter;[m
 reg [31:0] cycle_counter;[m
[36m@@ -151,7 +152,7 @@[m [malways @(posedge clk) begin[m
 [m
             STAGE_MEASUREMENT_PREPARING: begin // 7[m
                 if (input_valid && input_ready) begin[m
[31m-                    measurements[ALIGNED_PU_PER_ROUND-1:ALIGNED_PU_PER_ROUND-8] <= input_data;[m
[32m+[m[32m                        measurements[ALIGNED_PU_PER_ROUND-1:ALIGNED_PU_PER_ROUND-8] <= input_data;[m
                     if(ALIGNED_PU_PER_ROUND > 8) begin[m
                         measurements[ALIGNED_PU_PER_ROUND-9:0] <= measurements[ALIGNED_PU_PER_ROUND-1:8];[m
                     end[m
[36m@@ -165,17 +166,27 @@[m [malways @(posedge clk) begin[m
                         messages_per_round_of_measurement <= messages_per_round_of_measurement + 1;[m
                     end[m
                 end[m
[32m+[m[41m                [m
[32m+[m[32m                if(global_stage_previous == STAGE_PEELING) begin //new[m
[32m+[m[32m                    output_fifo_valid <= 1;[m
[32m+[m[32m                    messages_per_round_of_measurement <= 0;[m
[32m+[m[32m                    measurement_rounds <= 0;[m
[32m+[m[32m                end else begin[m
[32m+[m[32m                    output_fifo_valid = 0;[m
[32m+[m[32m                end[m
             end[m
 [m
             STAGE_MEASUREMENT_LOADING: begin[m
                 // Currently this is single cycle as only from external buffer happens.[m
                 // In future might need multiple[m
[31m-                if(measurement_rounds < GRID_WIDTH_U) begin[m
[32m+[m[32m                if(measurement_rounds < GRID_WIDTH_U/2) begin //new[m
                     global_stage <= STAGE_MEASUREMENT_PREPARING;[m
                     delay_counter <= 0;[m
                     result_valid <= 0;[m
                 end else begin[m
                     global_stage <= STAGE_GROW;[m
[32m+[m[32m                    measurement_rounds <= 0; //new[m
[32m+[m[41m                    [m
                     delay_counter <= 0;[m
                     result_valid <= 0;[m
                 end[m
[36m@@ -214,14 +225,14 @@[m [malways @(posedge clk) begin[m
                 end[m
             end[m
 [m
[31m-            STAGE_RESULT_VALID: begin //5[m
[31m-                measurement_rounds <= measurement_rounds + 1;[m
[31m-                if(measurement_rounds >= GRID_WIDTH_U - 1) begin[m
[31m-                    global_stage <= STAGE_IDLE;[m
[31m-                end[m
[31m-                delay_counter <= 0;[m
[31m-                result_valid <= 1;[m
[31m-            end[m
[32m+[m[32m//            STAGE_RESULT_VALID: begin //5[m
[32m+[m[32m//                measurement_rounds <= measurement_rounds + 1;[m
[32m+[m